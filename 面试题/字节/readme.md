# 基于这三点来回答问题
- xxx是什么？
- xxx特性 （优缺点）？
- xxx的应用场景？



# 什么是跨域？（请你聊一下跨域问题）
 - 同源策略
   1. 浏览器出于安全考虑（数据安全， 服务器安全， 减少 XSS， CSRF 攻击），
   2. http://   www.    abc.com :   8000    / a.html
    协议     子域名    主域名      端口号    路径
   3. 非同源，请求发送后，浏览器会拦截响应

 - 跨域方案
  1. jsonp: 
    1. 借助script 标签src属性不受同源策略限制，来发送请求
    2. 携带一个参数 callback 给到后端
    3. 后端将数据作为 callback 函数的实参，返回给前端一个 callback 的调用形式
    4. 浏览器接受到callback 的调用会自动执行全局的callback函数

  - 必须要前后端配合
  - 只能发送get请求
  - 不安全，容易受到xss攻击

  2. CORS:
    1. 后端设置 Access-Control-Allow-Origin: '域名白名单'，来通知浏览器哪些域名可以跨域访问

  3. nginx 反向代理
    1. 前端服务器和后端服务器不在同一个域名下， 前端服务器通过nginx 反向代理来访问后端服务器

  4. node 中间件代理
    1. 前端服务器和后端服务器不在同一个域名下， 前端服务器通过node 中间件来访问后端服务器

  
  
  5. websocket
    1. 传统的前后端通信是基于http协议的， 是单向的， 只能从一端发到另一端， 无法双向通信
    2. websocket 是基于tcp协议的， 是双向的， 可以从一端发送到另一端， 也可以从另一端发送到一端
    3. socket协议一旦建立链接， 就可以一直保持通信状态， 不需要每次都建立链接
    4. 天生就可以跨域

  6. postMessage
    当父级页面和iframe页面不在同一个域名下，他们之间的数据传输也存在跨域问题， 父级页面和iframe页面之间可以通过postMessage来通信

  7. document.domain
    同上 (谷歌禁用了 domain)



# 浏览器的存储方式
  1. localStorage （本地存储）  
      永久存储    5-10M    存储字符串类型的键值对      不能跨域访问

  2. sessionStorage  （会话存储）
     页面有效期   5-10M    存储字符串类型的键值对      不能跨域访问

  3. cookies  （）
     后端控制有效时长   4kb  存储字符串类型的键值对      可以设置跨域访问     
     会自动被携带在 http 的请求头中

  4. indexedDB  （客户端数据库）
     永久存储    无限大     可存储复杂的数据类型      不能跨域访问

# JWT
  1. 是一种认证方式
  2. 
  3. 

# 事件循环机制


# 归并排序
 - 分治
  1. 分解问题
  2. 求解每个子问题
  3. 合并子问题的解


# 浏览器缓存   
 
 1. 后端响应给浏览器的内容是需要在响应头中设置 编码类型的
 2. HTTP 分为 请求头和请求体 两部分，主要是提供一种内容协商机制
 3. 静态资源的传输


- HTTP 缓存
  将页面上长时间不更新的资源缓存到浏览器上，下次访问页面时该部分资源直接从缓存中获取，从而减少了网络请求的次数，提高了页面的加载速度。

  1. 强缓存： 
    在响应头中设置 Cache-Control 字段， 该字段的值为 max-age=xxx ， 表示缓存的有效期， 单位为秒。

    通过浏览器 url 地址栏请求的资源，请求头中就会自动携带 Cache-Control: max-age=0 字段， 也就意味着这种资源无法被强缓存

    被缓存的资源在浏览器的 cache Storage 中，本质上还是在硬盘上

    强制刷新浏览器，会清空浏览器的 cache Storage


  2. 协商缓存:
    强缓存对浏览器地址栏访问的资源无效，所以浏览器提供了协商缓存的机制

    - 浏览器第一次访问资源时，响应头中携带 last-modified 字段，值为该资源的最后修改时间，当浏览器接收到响应头后，会在该资源再次被请求时，在请求头中自动携带 if-modified-since 字段，值为last-modified的值，后端检验请求头中的if-modified-since 的值和 last-modified 的值是否一致，如果一致，就返回 304 状态码，浏览器就会从缓存中获取该资源，如果不一致，就返回 200 状态码，浏览器就会重新请求该资源。


    last-modified + if-modified-since 存在的问题：
      当文件被修改后但内容没有变更，last-modified 的值会更新，从而导致该资源从新被请求


    - 文件指纹： etag + if-none-match



只用强缓存可以吧除url地址栏访问的资源缓存起来，但是资源更新了就无法第一时间让前端获取到，所以还需要协商缓存

只要命中了强缓存，就不会走协商缓存， 只有强缓存到期，才会走协商缓存


为了保证文件资源更新前端能够及时获取到， 一般会在文件名后面加上文件指纹（用内容生成 hash 值）， 这样文件指纹就会改变， 从而保证文件资源的更新
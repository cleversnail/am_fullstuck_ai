# 进程和线程
1. 进程：CPU 在运行指令和保存上下文所需要的时间
2. 线程：执行一段指令所需要的时间

比如：浏览器美开一个 tab 页面，就是新开一个进程
1. 渲染线程
2. js 引擎线程
3. http 线程

渲染线程 和 js 引擎线程 是互斥的

# js是单线程
v8 引擎在运行 js 代码时，这个进程中只有一个线程会被开启


# event-loop
v8 按照先执行同步，在执行异步的策略，反复重复

1. 同步代码
2. 异步代码

  - 微任务：promise.then(), process.nextTick(), MutationObserver()

  - 宏任务：script， setTimeout, setInterval, setImmediate, 
  I/O, UI-rendering

eventLoop步骤：
1. 执行同步代码 (这属于宏任务)
2. 执行完同步后，检查是否有异步代码需要执行
3. 执行所有的微任务
4. 如果有需要，就渲染页面
5. 执行宏任务，也是开启了下一次事件循环


# await
1. 浏览器对 await 的执行提前了 （await 后面的代码当成同步来执行）
2. 会将后续（下面）代码挤入微任务队列


# setTimeout 定时器执行的时间准吗？
setTimeout被执行时，浏览器会启动一个新的线程来计时，等到时间结束才将定时器的回调取出来执行（js 主线程将其取出），如果此时 js 主线程还在执行同步代码，那么该回调就会一直挂起，直到同步执行完毕，微任务也执行完毕，才执行该回调
